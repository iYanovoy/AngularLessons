Typescript
============

1) <a href="#base">Базовые типы данных</a>
2) <a href="#boolean">Boolean</a>
3) <a href="#number">Number</a>
4) <a href="#string">String</a>
5) <a href="#array">Array</a>
6) <a href="#tuple">Tuple(Кортежи)</a>
7) <a href="#enum">Enum (Перечисления)</a>
8) <a href="#any">Any</a>
9) <a href="#void">Void</a>
10) <a href="#assertions">Type assertions (Приведение к типу)</a>
11) <a href="#functions">Функции</a>
12) <a href="#crossing">Пересечение типов</a>
13) <a href="#union">Объединение типов</a>
14) <a href="#alias">Псевдонимы("Alias") типа</a>
15) <a href="#literal">Тип строкового литерала</a>
16) <a href="#this">Полиморфный тип this</a>

### Строгая(или не очень) типизация

Прежде всего мы можем задавать типы нашим переменным. Так, вместо конструкции:

> const user = {
> name: "Vasya",
> id: 1
> };

Мы должны сначала объявить интерфейс:

> interface User {
>   name: string;
>   id: number;
> }

Теперь мы можем указать тип для нашей переменной:

> const user: User = {
> name: "Hayes",
> id: 0,
> };

#### Зачем нам все это нужно?

Все очень просто. Теперь мы точно знаем как минимум 2 факта о нашей переменно1: 

1) У нашей переменной есть поле `name` и оно является строкой.
2) У нашей переменной есть поле `id` и оно является числом.

#### Какая нам от этого польза?

Мы можем рассчитывать на то, что у нашего объекта есть то поле, которое нам необходимо и мы знаем его тип.
Соответственно, мы можем обращаться к методам, которые присущи данному типу. К тому же,
если мы в процессе разработки программы допустили ошибку и присвоили не тот тип данных, забыли точку с запятой
или же опечатались в имени переменной, компилятор предупредит нас об этом и выдаст ошибку на этапе сборки проекта.

### <b id=base>Базовые Типы данных</b>

## <b id=boolean>Boolean</b>

Базовый тип, с которым мы знакомы из курса JS, имеет 2 значения - `true` или `false`.

> let isDone: boolean = false;

## <b id=number>Number</b>

Как и в Javascript, тип numbers в Typescript являются числом с плавающей точкой. Поддерживает все те же возможности,
что и в JS.  

> let decimal: number = 6;
> 
> let hex: number = 0xf00d;
> 
> let binary: number = 0b1010;
>
> let octal: number = 0o744;

## <b id=string>String</b>

По аналогии с предыдущими типами данных, перекочевал с JavaScript без изменений.  

> let name: string = "bob";
> 
> name = 'smith';
> 
> name = \`Will ${name}\`

## <b id=array>Array</b>

Массивы имеют небольшие изменения. Теперь мы можем указывать какого типа данный массив. Имеет два вида записи.

> let list: number[] = [1, 2, 3];

и

> let list: Array<span>\<number\></span> = [1, 2, 3];

## <b id=tuple>Tuple(Кортежи)</b>

Тип Tuple дает вам возможность объявить массив с известным фиксированным количеством элементов, которые не обязаны быть одного типа.

Объявление типа tuple
> let x: [string, number];

Его инициализация
> x = ['Vasya', 30]; // OK

Некорректная инициализация вызовет ошибку
> x = [30, 'Vasya']; // Error

При получении элемента с индексом вне известного диапазона, будет возвращен тип любой из тех, который был объявлен:

> x[3] = 'world'; // Не вызывает ошибок, тип string может быть присвоен (string | number)

> console.log(x[5].toString()); // OK, 'string' и 'number' оба имеют метод toString

> x[6] = true; // Ошибка, boolean это не (string | number)

## <b id=enum>Enum (Перечисления)</b>

Представляет собой именованое представление чисел. Пары "имя" - "число". 

> enum Color {Red, Green, Blue};

> let c: Color = Color.Green; // Переменная с содержит значение 1

По умолчанию перечисления (Enum) начинаются с 0. Вы можете изменить это путем прямого указания значения для одного из членов перечисления.
Например, мы можем начать предыдущий пример с 1 вместо 0:

> enum Color {Red = 1, Green, Blue};

> let c: Color = Color.Green; // Переменная с содержит значение 2

Либо же задать значения для всех членов:

> enum Color {Red = 1, Green = 3, Blue = 5};

> let c: Color = Color.Green; // Переменная с содержит значение 3

Удобная особенность перечислений состоит в том, что вы также можете получить имя члена перечисления, передав его числовое значение.
Например, если у нас есть значение 2 и мы хотим посмотреть, чему оно соответствует в перечислении Color описанном выше,
мы можем сделать это так:
> enum Color {Red = 1, Green, Blue};

> let colorName: string = Color[2]; // Переменная colorName содержит значение "Green"

## <b id=any>Any</b>

Тип данных, который говорит нам, что данные могут быть любого типа. Часто используется когда мы не знаем наверняка тип,
он будет получен позже (от сервера или пользователя) или же, если мы хотим проигнорировать проверку на тип.

> let anything: any = 4;

> anything = "maybe a string instead";

> anything = false; // Ошибок не будет, так как мы задали неопределенный тип

Использование `any` считается плохой практикой, так как мы не знаем как работать наверняка с этим типом данных,
какие у него есть поля и методы. Но иногда, нам нужно его использовать, чтобы избежать ошибок компиляции. Например,
если у нас переменная будет получена от какой-то библиотеки, и мы не знаем наверняка, какой там тип.

## <b id=void>Void</b>

Тип данных, которые используется чтобы показать, что наша функция ничего не возвращает:

> function helloWorld(): void {
>    console.log("Hello World");
> }

Если задать тип `void` переменной, то присвоить вы туда сможете только `null` или `undefined`, что делает такую переменную бесполезной.

> let unusable: void = undefined;

## <b id=assertions>Type assertions (Приведение к типу)</b>

Иногда нам нужно сказать компилятору, что переменная будет иного типа, нежели ожидается. Это может быть в случае когда тип не был задан,
был задан неверно или был изменен в процессе работы программы.

Приведение к типу не делает никаких специальных проверок или реструктуризаций данных.
Приведение к типу не имеет никакого воздействия на этапе выполнения программы и используется только компилятором.
Typescript предполагает, что программист сделает все необходимые проверки, которые потребуются.

Приведение к типу может быть сделано двумя способами. Первый это использование синтаксиса угловых скобок:

> let someValue: any = "this is a string";

> let strLength: number = (<string>someValue).length;

И другой - использование ключевого слова as:

> let someValue: any = "this is a string";

> let strLength: number = (someValue as string).length;

## <b id=functions>Функции</b>

Как и в JavaScript, в TypeScript функции могут быть присвоены переменным. Соответственно они должны иметь свой тип.
В основном, объявления типа функции похоже на стрелочные функции:

> let myAdd: (x: number, y: number) => number = function(x: number, y: number): number { return x+y; };

Тип функции состоит из таких же двух частей: типа аргументов и типа возвращаемого значения.
Когда записывается полный тип функции, указывать необходимо обе эти части. Типы параметров записываются так же, как и список параметров, и каждому параметру присваивается имя и тип.
Имена здесь нужны только для удобства чтения, можно было бы написать, к примеру, вот так:

> let myAdd: (baseValue: number, increment: number) => number = function(x: number, y: number): number { return x + y; };

Если типы параметров совпадают, то тип считается подходящим для функции, и не важно,
какие имена были даны параметрам в описании типа функции.

## <b id=crossing>Пересечение типов<b>

Когда мы ожидаем, что переменная может быть такого типа, или другого, мы можем указать эти типы как объединение:

> let width: string | number;

> width = 30; // Не вызовет ошибок

> width = '30px'; // Так же не вызовет ошибок

Если у нас есть значение типа объединения, мы можем получить доступ только к тем его элементам,
которые являются общими для всех типов в объединении.

> width.toString(); // Не вызовет ошибок, так как есть и у `string`, и у `number`

> width.length(); // Вызовет ошибку, так как есть только у типа `string`

Это реализовано для того, чтобы вы нечаянно не вызвали метод присущий для другого типа.

Чтобы код, содержащий специфичные методы работал, нам нужно воспользоваться утверждением типа (type assertion):

> (width as String).length();

> (<String>width).length();

P.S. в новых версиях не работает, нужно проверять на тип руками:

> if (typeof width === 'string') {
>    width.length()
> }

## <b id=union>Объединение типов</b>

Говорит нам, что переменная будет содержать методы и того, и другого типа:

> class Animal {
>   run(): string {
>       return 'Run';
>   }
> }

> class Fish {
>   swim(): string {
>       return 'Swim';
>   }
> }

> let frog: Animal & Fish = {} as any;

> frog.swim();

## <b id=alias>Псевдонимы("Alias") типа</b>

Псевдонимы типа создают новое имя для типа. Псевдонимы типа иногда похожи на интерфейсы, но могут именовать примитивы,
объединения, кортежи и любые другие типы, которые в противном случае Вам пришлось бы именовать вручную.

> type Name = string;

> type NameResolver = () => string;

> type NameOrResolver = Name | NameResolver;

> function getName(n: NameOrResolver): Name {
>   if (typeof n === "string") {
>       return n;
>   } else {
>       return n();
>   }
> }

## <b id=literal>Тип строкового литерала</b>

Тип строкового литерала позволяет Вам указывать точное значение строки, которое она должна иметь.
На практике тип строкового литерала хорошо комбинируется с типом объединения, защитниками типа и типом Псевдонима.
Вы можете использовать эти функции вместе, чтобы получить поведение со строками как у перечисления.

> type AnimationString = "ease-in" | "ease-out" | "ease-in-out";

> let animationType: AnimationString;

> animationType = 'ease-in'; // Нет ошибки

> animationType = 'easy'; // Ошибка, значение недопустимо

## <b id=this>Полиморфный тип this</b>

Полиморфный тип this представляет тип, являющийся подтипом содержащегося класса или интерфейса.
Называется F-bounded полиморфизмом. И позволяет намного легче выразить иерархически плавающие интерфейсы, например.
Возьмём простой калькулятор, возвращающий this после каждой операции:

> class BasicCalculator {
> 
>   public constructor(protected value: number = 0) { }
> 
>   public currentValue(): number {
>       return this.value;
>   }
> 
>   public add(operand: number): this {
>       this.value += operand;
>       return this;
>   }
> 
>   public multiply(operand: number): this {
>       this.value *= operand;
>       return this;
>   }
> 
>   // ... другие операции ...
> 
> }

> let v = new BasicCalculator(2).multiply(5).add(1).currentValue();

